/* CMeterG2553: MSP430G2553 имеет компаратор, который можно использовать
*  для измерения ёмкости конденсатора в RC цепочке,
*  когда он объединён с таймером.
*  Компаратор настроен на опорное напряжение 1/4 Vcc, и останавливает таймер,
*  когда порог пересекается. Значение времени зависит от ёмкости, а точность
*  измерения, главным образом, зависит от точности размера сопротивления,
*  известного нам. Требуются калиброванный источник тактового сигнала, для
*  точного подсчёта времени.
*
*  Данная версия не включает серийного соединения с компьютером для
*  считывания результата, и изменение света на  светодиодах (P1.0 и P1.6),
*  сигнализирует о завершении измерения. Затем пользователь может
*  нажать паузу в отладчике CCS, и посмотреть результат в регистрах.
*  Резистор присоединён к выводам P1.5 и P1.1, конденсатор к выводам P1.1 и земле.
*
*  		--|||||||||------| |----
*  		|			|			|
*    P1.5		P1.1		 GND
*
*  У LaunchPad, перемычка на TXD, должна быть снята, для использования P1.1
*  в этом проекте.
*/

#include <msp430g2553.h>

#define LED1    BIT0
#define LED2    BIT6
#define BTN1   BIT3
#define VCTL    BIT5
#define AIN1    BIT1

/*  Глобальные переменные  */
unsigned int overflows;

/*  Обявления функций  */
void P1init(void);
void CAinit(void);
void TAinit(void);

void main(void) {

    WDTCTL = WDTPW + WDTHOLD;   // Отключаем сторожевой таймер

    BCSCTL1 = CALBC1_1MHZ;
    DCOCTL = CALDCO_1MHZ;       // Такты, - калиброванный 1 мГц

    for( ; ; ) {           // бесконечный цикл
        P1init();
        CAinit();
        TAinit();
        _BIS_SR(LPM0_bits + GIE);

        overflows = 0;    // Сброс счётчика переполнений
        P1OUT = LED1;     // Гасим LED2, зажигаем LED1 (красный) показать, что идёт измерение.
        TACTL |= MC_2;   // Старт таймера в непрерывном режиме,
                         // выход TA0.0 устанавливается по переполнению.
        while (overflows < 10);

        CACTL1 |= CAON;            // Включаем компаратор
        TACCTL0 = OUTMOD_5 + CCIE; // После следующего переполнения включаем разряд
        TACCTL1 |= CM_2; // Захват из TA1 по спадающему фронту сигнала
        overflows = -1;  // Сброс счётчика переполнений (считаем одно переполнение
                         // и начинаем разряд конденсатора).

        _BIS_SR(LPM0_bits + GIE);

    }

} // main

void P1init(void) {
    P1OUT = LED2;    // LED2 (зеленый) зажигается, показывая готовность.
    P1DIR = LED1 + LED2 + VCTL; // Выходы на P1.0 и P1.6 для светодиодов,
                                // P1.5 для контроля напряжения на RC цепи.
    P1SEL = VCTL; // Назначаем P1.5 на выход от TA0.0, для контроля заряда/разряда

    // Следующие две строчки нужны для инициализации кнопки на LaunchPad 1.5
    P1REN |= BTN1;    // Разрешение подтяжки для P1.3
    P1OUT |= BTN1;    // Подтяжка P1.3 вверх
    P1IES = BTN1; // Прерывание по спадающему фронту для кнопки с подтяжкой вверх
    P1IFG &= ~BTN1; // Обнуляем флаг прерывания перед разрешением
    P1IE = BTN1;    // Разрешаем прерывание для BTN1

} // P1init

void CAinit(void) {
    CACTL1 = CARSEL + CAREF_1;  ; // Опорное напряжение 0.25 Vcc,
                                  // на инвертирующем входе.
    CACTL2 = P2CA4 + CAF;      // Вывод CA1 неинвертирующий вход,
                               // фильтр на выходе.
    CAPD = AIN1;               // Отключаем цифровой блок на P1.7 (технически
                               // этот шаг избыточен).
} // CAinit

void TAinit(void) {
    TACTL = TASSEL_2 + ID_0 + MC_0; // Используем SMCLK (калиброванные 1 MHz)
                                    // без делителя, таймер остановлен.
    TACCTL0 = OUTMOD_1 + CCIE; // Выход TA0.0 устанавливается по достижении TACCR0
    TACCTL1 = CCIS_1 + SCS + CAP + CCIE; // Используем CAOUT для входа,
                                         // синхронный захват, режим захвата
                                         // разрешаем прерывания TA1.
                                         // ВНИМАНИЕ: захват пока не работает
} // TAinit

/*  Обработчики прерываний  */
#pragma vector = PORT1_VECTOR
__interrupt void P1_ISR(void) {
    switch(P1IFG & BIT3) {
        case BIT3:
            P1IFG &= ~BIT3;  // Обнуляем флаг прерывания
            if ((P1OUT & LED1)==LED1)
                return; // Идёт измерение, не реагируем на нажатие кнопки
            else {
                __low_power_mode_off_on_exit(); // Кнопка нажата; продолжаем выполнение программы
                return;
            }
        default:
            P1IFG = 0;  // Обнуляем все случайные флаги прерываний
            return;
    }
} // P1_ISR


#pragma vector = TIMER0_A0_VECTOR
__interrupt void TA0_ISR(void) {
    overflows++;    // Прерывание TA0 возникает, когда Timer_A досчитывает до 2^16,
                    // без прерывания от  Comparator_A
                    // счётчик TAR сбрасывается в 0, добавляем одно переполнение.
} // TA0_ISR

#pragma vector = TIMER0_A1_VECTOR
__interrupt void TA1_ISR(void) {
    TACCTL1 &= ~(CM_2 + CCIFG); // Останавливаем захват для TA1, обнуляем флаг прерывания.
    TACTL &= ~MC_2;     // Останавливаем Timer_A
    P1OUT = LED2;       // Измерение завершено, включаем зеленый светодиод
    __low_power_mode_off_on_exit();    // Продолжаем выполнение программы
} // TA1_ISR
